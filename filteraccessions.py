import sys, re

outdir=sys.argv[1]
accessionfile='%s/accessions.tsv'%outdir

#set up regular expression exclusion
regexObjexclude=re.compile(r'\bcontig\b|\bscaffold\b|\bgenes?\b|\bintegrons?\b|\btransposons?\b|insertion sequences?|insertion elements?|\bphages?\b|\boperons?\b|\bpartial\b|\bregions?\b|\bfragments?\b|\blocus\b|\bloci\b|whole genome shotgun|whole genome map|\bartificial\b|\bsynthetic\b|\bvector\b',re.I)
#regular expressions: | indicates alterantives; ? indicates zero or one of the preceeding character; \b indicates word boundary; re.I specifies case insensitive matching

#iterate through accessions, filtering according to regular expression exclusion criteria
f2=open('%s/accessions_filtered.tsv'%outdir,'w')
f3=open('%s/excludedaccessions.tsv'%outdir,'w')
f2.write('Accession\tTopology\tLength\tTitle\tCompleteness\n')
f3.write('Accession\tTopology\tLength\tTitle\tCompleteness\n')
with open(accessionfile) as f:
    for indx, line in enumerate(f):
        if indx==0: #header line
            continue
        line=line.strip()
        description=line.split('\t')[3]  #!!!need to convert to lower case, or use re.I above
        #print(indx, line)
        #print(description)
        regexexclude=regexObjexclude.findall(description) #regexexclude is a list of any regular expression terms which have a match in the accession description
        if len(regexexclude)==0:
            f2.write('%s\n'%line)
        else:
            f3.write('%s\n'%line)

f2.close()
f3.close()


###OLD CODE

#regexObjexclude=re.compile('contig|\sgene(?!tic|ral|rat|ric)|integron|transposon|scaffold|insertion sequence|insertion element|phage|operon|partial sequence|partial plasmid|region|fragment|locus|complete (?!sequence|genome|plasmid|\.|,)|(?<!complete sequence, )whole genome shotgun|artificial|synthetic|vector')
#regular expressions: | indicates alterantives; \s matches whitespace; string (?!...) negative lookahead i.e. string matching only if sting is not followed by ...
# \sgene(?!tic|ral|rat|ric) to account for 3rd generation cephalo; generated by etc. n.b previously had (?!.*tic.. * : means zero or more matches to preceeding character (.) . : means any character [not sure why I had this]


#regular expression inclusion
#regexObjinclude=re.compile('complete(?= sequence| genome| plasmid)')



# #OLDER CODE
# #first find bad accessions and write enterobacrecord to file without them

# fileObj = open("%s/2nd_task/output/%s/%srecorddownload_v1.tsv" %(filepath,sys.argv[1],sys.argv[1]))
# fileObj1=open("%s/2nd_task/output/%s/%srecorddownload_v2.tsv" %(filepath,sys.argv[1],sys.argv[1]), "w")
# fileObj2= open("%s/2nd_task/output/%s/%srecorddownload_badaccessions.tsv" %(filepath,sys.argv[1],sys.argv[1]), "w")

# #more relaxed filtering; removed genomic sequence, genomic assembly - relying on completeness tag to filter later

# regexObj=re.compile('contig|\sgene(?!tic|ral|rat|ric)|integron|transposon|scaffold|insertion sequence|insertion element|phage|operon|partial sequence|partial plasmid|region|fragment|locus|complete (?!sequence|genome|plasmid|\.|,)|(?<!complete sequence, )whole genome shotgun|artificial|synthetic|vector') #regular expressions: | indicates alterantives; \s matches whitespace; string (?!...) negative lookahead i.e. string matching only if sting is not followed by ...
# # \sgene(?!tic|ral|rat|ric) to account for 3rd generation cephalo; generated by etc. n.b previously had (?!.*tic.. * : means zero or more matches to preceeding character (.) . : means any character [not sure why I had this]

# #n.b for complete ... filtering, checked in badaccessoins - only 3, and all not plasmids

# contigcounter=0
# genecounter=0
# integroncounter=0
# transposoncounter=0
# scaffoldcounter=0
# insertionsequencecounter=0
# insertionelementcounter=0
# phagecounter=0
# #resistanceregioncounter=0 #just include region
# operoncounter=0
# partialsequencecounter=0
# partialplasmidcounter=0
# #genomicsequencecounter=0  #some genomic sequence/genomic assembly accessions may be complete assemblies - can check manually
# #genomicassemblycounter=0
# regioncounter=0
# fragmentcounter=0
# locuscounter=0
# completecounter=0
# wgscounter=0
# artificialcounter=0 #added these 3 lines in case a cloning vector slipped through the net
# syntheticcounter=0
# vectorcounter=0




# badaccessions=[]
# for indx, line in enumerate(fileObj):
#     data=line.split('\t')
#     description=str(data[1]).lower() #record description in lower case
#     regexresult=regexObj.findall(description) #regexresult is a list of any regular expression terms which have a match in the accession description
#     if len(regexresult)==0:
#         fileObj1.write(line)
#     else:
#         fileObj2.write(line)
#         badaccessions.append(data[0])
#         match=set(regexresult) #deduplicates - if there are multiple matches to the same regular expression term - not intereted in this
#         if len(match)==1:
#             if 'contig' in match:
#                 contigcounter=contigcounter+1
#             if ' gene' in match:
#                 genecounter=genecounter+1
#             if 'integron' in match:
#                 integroncounter=integroncounter+1
#             if 'transposon' in match:
#                 transposoncounter=transposoncounter+1
#             if 'scaffold' in match:
#                 scaffoldcounter=scaffoldcounter+1
#             if 'insertion sequence' in match:
#                 insertionsequencecounter=insertionsequencecounter+1
#             if 'insertion element' in match:
#                 insertionelementcounter=insertionelementcounter+1
#             if 'phage' in match:
#                 phagecounter=phagecounter+1
#             #if 'resistance region' in match:
#             #    resistanceregioncounter=resistanceregioncounter+1
#             if 'operon' in match:
#                 operoncounter=operoncounter+1
#             if 'partial sequence' in match:
#                 partialsequencecounter=partialsequencecounter+1
#             if 'partial plasmid' in match:
#                 partialplasmidcounter=partialplasmidcounter+1
#             #if 'genomic sequence' in match:
#             #    genomicsequencecounter=genomicsequencecounter+1
#             #if 'genomic assembly' in match:
#             #    genomicassemblycounter=genomicassemblycounter+1
#             if 'region' in match:
#                 regioncounter=regioncounter+1
#             if 'fragment' in match:
#                 fragmentcounter=fragmentcounter+1
#             if 'locus' in match:
#                 locuscounter=locuscounter+1
#             if 'complete' in match:
#                 completecounter=completecounter+1
#             if 'whole genome shotgun' in match:
#                 wgscounter=wgscounter+1
#             if 'artificial' in match:
#                 artificialcounter=artificialcounter+1
#             if 'synthetic' in match:
#                 syntheticcounter=syntheticcounter+1
#             if 'vector' in match:
#                 vectorcounter=vectorcounter+1
            
                
#         if len(match)>1:
#             print match, "multiple match"




# print len(badaccessions), "len badaccessions"
# savepickle(badaccessions, "%s/2nd_task/output/%s/pickle.%sbadaccessions" %(filepath,sys.argv[1],sys.argv[1])) 


# print badaccessions[0:2], "bad accessions 1-2"

# print contigcounter, "contigs"
# print genecounter, "genes"
# print integroncounter, "integrons"
# print transposoncounter, "transposons"
# print scaffoldcounter, "scaffolds"
# print insertionsequencecounter, "insertion seq"
# print insertionelementcounter, "insertion element"
# print phagecounter, "phage"
# #print resistanceregioncounter, "resistance"
# print operoncounter, "operon"
# print partialsequencecounter, "partial sequence"
# print partialplasmidcounter, "partial plasmid"
# #print genomicsequencecounter, "genomic sequence"
# #print genomicassemblycounter, "genomic assembly"
# print regioncounter, "region"
# print fragmentcounter, "fragment"
# print locuscounter, "locus"
# print completecounter, "complete"
# print wgscounter, "shotgun"
# print artificialcounter, "artificial"
# print syntheticcounter, "synthetic"
# print vectorcounter, "vector"


# fileObj.close()
# fileObj1.close()
# fileObj2.close()


# #################


# #from recorddownload_v2, write file with includedaccessions (good) and unincluded accesions (neither good nor bad) 

# fileObj = open("%s/2nd_task/output/%s/%srecorddownload_v2.tsv" %(filepath,sys.argv[1],sys.argv[1]))
# fileObj1=open("%s/2nd_task/output/%s/%srecorddownload_includedaccessions.tsv" %(filepath,sys.argv[1],sys.argv[1]), "w")
# fileObj2= open("%s/2nd_task/output/%s/%srecorddownload_unincludedaccessions.tsv" %(filepath,sys.argv[1],sys.argv[1]), "w")

# regexObjinclude=re.compile('complete(?= sequence| genome| plasmid)')

# unincludedaccessions=[]
# for indx, line in enumerate(fileObj):
#     data=line.split('\t')
#     description=str(data[1]).lower() #record description in lower case
#     regexresult=regexObjinclude.findall(description) #regexresult is a list of any regular expression terms which have a match in the accession description
#     if len(regexresult)==0:
#         fileObj2.write(line) #if the inclusion criteria aren't matched, write to unincluded accessions file
#         unincludedaccessions.append(data[0])
#     else:
#         fileObj1.write(line) #if there is a match, write included accessions to file

# print unincludedaccessions
# print len(unincludedaccessions)
# fileObj.close()
# fileObj1.close()
# fileObj2.close()

                                



# #OLD CODE


# #conservative filtering
# """
# regexObj=re.compile('contig|\sgene(?!tic|ral|rat|ric)|integron|transposon|scaffold|insertion sequence|insertion element|phage|operon|partial sequence|partial plasmid|genomic sequence|genomic assembly|region|fragment|locus|artificial|synthetic|vector|complete (?!sequence|genome|plasmid|\.|,)|(?<!complete sequence, )whole genome shotgun') #regular expressions: | indicates alterantives; \s matches whitespace; string (?!...) negative lookahead i.e. string matching only if sting is not followed by ...; (?<!a),b negative lookbehind i.e. match a only if it is not preceeded by b
# # \sgene(?!tic|ral|rat|ric) to account for 3rd generation cephalo; generated by etc. n.b previously had (?!.*tic.. * : means zero or more matches to preceeding character (.) . : means any character [not sure why I had this]

# # added genomic sequence ... etc.
# #complete (?!sequence|genome|plasmid|\.|,)|(?<!complete sequence, )whole genome shotgun  #first term removes complete ... as long as ...is not seuqence, genome etc.; second term removes whole genome shotgun unless it's preceeded by complete sequence
# """

# #unecessary pickling
# #savepickle(unincludedaccessions, "%s/2nd_task/output/%s/pickle.unincludedaccessions" %filepath)



















#####################################

#OLD CODE - PRE NOVEMBER 2016 

#use bad accessoins to re-write other files - leave till later
"""
fileObj1 = open("%s/2nd_task/enterobacfeaturesdownload_v1.tsv" %filepath) 
fileObj2 = open("%s/2nd_task/enterobacfeaturesdownload_v2.tsv" %filepath, "w")
fileObj3 = open("%s/2nd_task/enterobacnucleotideseqdownload_v1.tsv" %filepath)#also contains protein sequences so no need for separate code in extractproteins directory writing enterobactranslationdown load.tsv (as done previously)
fileObj4 = open("%s/2nd_task/enterobacnucleotideseqdownload_v2.tsv" %filepath, "w")



badindices=[]  #because enterobacnucleotideseqdownload doesn't have accessions, but rows correspond to enterobacfeaturesdownload which does have accessions, create a list of indices to allow filtering of nucleotideseq rows
for indx, line in enumerate(fileObj1):
    data=line.split('\t')
    accession=data[0]
    if accession in badaccessions:
        badindices.append(indx)
        continue
    else:
        fileObj2.write(line)


for indx, line in enumerate(fileObj3):
    if indx in badindices:
        continue
    else:
        fileObj4.write(line)

        

fileObj1.close()
fileObj2.close()
fileObj3.close()
fileObj4.close()
"""


#################################################################


#NEXT: apply inclusion criteria regexObjinclude=re.compile('complete(?= sequence| genome| plasmid)'); then manully check sequences not included to confirm they can be included




        
#OLD CODE

        
"""
        matchedstring=str(regexresult.group())
        if matchedstring=="contig":
            contigcounter=contigcounter+1
        if matchedstring==" gene":
            genecounter=genecounter+1
        if matchedstring=="integron":
            integroncounter=integroncounter+1
        if matchedstring=="transposon":
            transposoncounter=transposoncounter+1
        if matchedstring=="scaffold":
            scaffoldcounter=scaffoldcounter+1
"""
